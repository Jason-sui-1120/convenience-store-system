# 数据库设计文档

> 便利店进销存系统数据库设计  
> 基于Supabase PostgreSQL  
> 更新时间: 2025年2月1日  
> 版本: v2.1.0

## 🎯 设计概述

本系统采用Supabase PostgreSQL作为主数据库，设计遵循关系型数据库规范化原则，通过外键关联和中间表实现数据完整性和一致性。数据库包含五个核心表：供应商表、商品表、供应商-商品关联表、入库记录表和出库记录表。

## 📊 数据库架构

### 核心表关系
```
suppliers (供应商表)
    ↓ (M:N) 通过 supplier_products 中间表
products (商品表)
    ↓ (1:N)
inbound_records (入库记录表) ← product_id, supplier_id
    ↓ (1:N)  
outbound_records (出库记录表) ← product_id

supplier_products (供应商-商品关联表)
    ← supplier_id (M:1) suppliers
    ← product_id (M:1) products
```

## 📋 表结构设计

### 1. suppliers (供应商表)

**表名**: `suppliers`  
**描述**: 存储供应商基本信息和联系方式

| 字段名 | 数据类型 | 约束 | 默认值 | 描述 |
|--------|----------|------|--------|------|
| id | SERIAL | PRIMARY KEY | AUTO | 供应商唯一标识 |
| name | VARCHAR(255) | NOT NULL | - | 供应商名称 |
| contact | VARCHAR(100) | NOT NULL | - | 联系人姓名 |
| phone | VARCHAR(20) | NOT NULL | - | 联系电话 |
| address | TEXT | NULL | - | 供应商地址 |
| paymentMethod | VARCHAR(50) | NOT NULL | - | 付款方式 |
| hasInvoice | BOOLEAN | NOT NULL | false | 是否开具发票 |
| status | VARCHAR(20) | NOT NULL | 'active' | 供应商状态 |
| remark | TEXT | NULL | - | 备注信息 |
| created_at | TIMESTAMP | NOT NULL | NOW() | 创建时间 |
| updated_at | TIMESTAMP | NOT NULL | NOW() | 更新时间 |

**索引设计**:
```sql
-- 主键索引（自动创建）
CREATE INDEX idx_suppliers_id ON suppliers(id);

-- 名称索引（用于搜索）
CREATE INDEX idx_suppliers_name ON suppliers(name);

-- 状态索引（用于筛选）
CREATE INDEX idx_suppliers_status ON suppliers(status);
```

**示例数据**:
```json
{
  "id": 8,
  "name": "北京食品供应商",
  "contact": "张经理",
  "phone": "13800138001",
  "address": "北京市朝阳区建国路88号",
  "paymentMethod": "银行转账",
  "hasInvoice": true,
  "status": "active",
  "remark": "长期合作伙伴，信誉良好"
}
```

### 2. products (商品表)

**表名**: `products`  
**描述**: 存储商品基本信息、价格和库存数据

| 字段名 | 数据类型 | 约束 | 默认值 | 描述 |
|--------|----------|------|--------|------|
| id | SERIAL | PRIMARY KEY | AUTO | 商品唯一标识 |
| name | VARCHAR(255) | NOT NULL | - | 商品名称 |
| brand | VARCHAR(100) | NOT NULL | - | 商品品牌 |
| category | VARCHAR(100) | NOT NULL | - | 商品分类 |
| specification | VARCHAR(100) | NOT NULL | - | 商品规格 |
| purchasePrice | DECIMAL(10,2) | NOT NULL | - | 进货价格 |
| inputPrice | DECIMAL(10,2) | NOT NULL | - | 录入价格 |
| retailPrice | DECIMAL(10,2) | NOT NULL | - | 零售价格 |
| currentStock | INTEGER | NOT NULL | 0 | 当前库存数量 |
| stockAlert | INTEGER | NULL | 10 | 库存预警值 |
| unit | VARCHAR(20) | NOT NULL | - | 计量单位 |
| barcode | VARCHAR(50) | NULL | - | 商品条码 |
| created_at | TIMESTAMP | NOT NULL | NOW() | 创建时间 |
| updated_at | TIMESTAMP | NOT NULL | NOW() | 更新时间 |

**索引设计**:
```sql
-- 主键索引（自动创建）
CREATE INDEX idx_products_id ON products(id);

-- 商品名称索引（用于搜索）
CREATE INDEX idx_products_name ON products(name);

-- 品牌分类复合索引
CREATE INDEX idx_products_brand_category ON products(brand, category);

-- 条码唯一索引
CREATE UNIQUE INDEX idx_products_barcode ON products(barcode) WHERE barcode IS NOT NULL;

-- 库存预警索引
CREATE INDEX idx_products_stock_alert ON products(currentStock, stockAlert);
```

**示例数据**:
```json
{
  "id": 15,
  "name": "可口可乐",
  "brand": "可口可乐",
  "category": "饮料",
  "specification": "500ml",
  "purchasePrice": 2.50,
  "inputPrice": 2.80,
  "retailPrice": 3.50,
  "currentStock": 100,
  "stockAlert": 20,
  "unit": "瓶",
  "barcode": "6901234567890"
}
```

### 3. supplier_products (供应商-商品关联表)

**表名**: `supplier_products`  
**描述**: 管理供应商与商品的多对多关系

| 字段名 | 数据类型 | 约束 | 默认值 | 描述 |
|--------|----------|------|--------|------|
| id | SERIAL | PRIMARY KEY | AUTO | 关联记录唯一标识 |
| supplier_id | INTEGER | NOT NULL | - | 关联供应商ID |
| product_id | INTEGER | NOT NULL | - | 关联商品ID |
| is_primary | BOOLEAN | NOT NULL | false | 是否为主要供应商 |
| created_at | TIMESTAMP | NOT NULL | NOW() | 创建时间 |

**外键约束**:
```sql
ALTER TABLE supplier_products 
ADD CONSTRAINT fk_supplier_products_supplier 
FOREIGN KEY (supplier_id) REFERENCES suppliers(id) 
ON DELETE CASCADE ON UPDATE CASCADE;

ALTER TABLE supplier_products 
ADD CONSTRAINT fk_supplier_products_product 
FOREIGN KEY (product_id) REFERENCES products(id) 
ON DELETE CASCADE ON UPDATE CASCADE;

-- 唯一约束：同一供应商和商品只能有一条关联记录
ALTER TABLE supplier_products 
ADD CONSTRAINT uk_supplier_product 
UNIQUE (supplier_id, product_id);
```

**索引设计**:
```sql
-- 供应商外键索引
CREATE INDEX idx_supplier_products_supplier ON supplier_products(supplier_id);

-- 商品外键索引
CREATE INDEX idx_supplier_products_product ON supplier_products(product_id);

-- 主要供应商索引
CREATE INDEX idx_supplier_products_primary ON supplier_products(is_primary) WHERE is_primary = true;
```

**示例数据**:
```json
{
  "id": 1,
  "supplier_id": 8,
  "product_id": 15,
  "is_primary": true,
  "created_at": "2025-01-31T10:00:00Z"
}
```
### 4. inbound_records (入库记录表)

**表名**: `inbound_records`  
**描述**: 记录商品入库操作的详细信息

| 字段名 | 数据类型 | 约束 | 默认值 | 描述 |
|--------|----------|------|--------|------|
| id | SERIAL | PRIMARY KEY | AUTO | 入库记录唯一标识 |
| product_id | INTEGER | NOT NULL | - | 关联商品ID |
| supplier_id | INTEGER | NOT NULL | - | 关联供应商ID |
| quantity | INTEGER | NOT NULL | - | 入库数量 |
| unit_price | DECIMAL(10,2) | NOT NULL | - | 入库单价 |
| total_amount | DECIMAL(10,2) | NOT NULL | - | 入库总金额 |
| date | DATE | NOT NULL | - | 入库日期 |
| notes | TEXT | NULL | - | 备注信息 |
| created_by | VARCHAR(100) | NOT NULL | 'system' | 创建人 |
| updated_by | VARCHAR(100) | NOT NULL | 'system' | 更新人 |
| created_at | TIMESTAMP | NOT NULL | NOW() | 创建时间 |
| updated_at | TIMESTAMP | NOT NULL | NOW() | 更新时间 |

**外键约束**:
```sql
ALTER TABLE inbound_records 
ADD CONSTRAINT fk_inbound_product 
FOREIGN KEY (product_id) REFERENCES products(id) 
ON DELETE CASCADE ON UPDATE CASCADE;

ALTER TABLE inbound_records 
ADD CONSTRAINT fk_inbound_supplier 
FOREIGN KEY (supplier_id) REFERENCES suppliers(id) 
ON DELETE CASCADE ON UPDATE CASCADE;
```

**索引设计**:
```sql
-- 商品外键索引
CREATE INDEX idx_inbound_product_id ON inbound_records(product_id);

-- 供应商外键索引
CREATE INDEX idx_inbound_supplier_id ON inbound_records(supplier_id);

-- 日期索引（用于时间范围查询）
CREATE INDEX idx_inbound_date ON inbound_records(date);

-- 复合索引（商品+日期）
CREATE INDEX idx_inbound_product_date ON inbound_records(product_id, date);
```

**示例数据**:
```json
{
  "id": 25,
  "product_id": 15,
  "supplier_id": 8,
  "quantity": 50,
  "unit_price": 2.50,
  "total_amount": 125.00,
  "date": "2025-01-08",
  "notes": "正常入库，质量良好",
  "created_by": "system",
  "updated_by": "system",
  "created_at": "2025-02-01T10:00:00Z",
  "updated_at": "2025-02-01T10:00:00Z"
}
```

### 5. outbound_records (出库记录表)

**表名**: `outbound_records`  
**描述**: 记录商品出库操作的详细信息

| 字段名 | 数据类型 | 约束 | 默认值 | 描述 |
|--------|----------|------|--------|------|
| id | SERIAL | PRIMARY KEY | AUTO | 出库记录唯一标识 |
| product_id | INTEGER | NOT NULL | - | 关联商品ID |
| quantity | INTEGER | NOT NULL | - | 出库数量 |
| unit_price | DECIMAL(10,2) | NOT NULL | - | 出库单价 |
| total_amount | DECIMAL(10,2) | NOT NULL | - | 出库总金额 |
| date | DATE | NOT NULL | - | 出库日期 |
| customer_name | VARCHAR(100) | NULL | - | 客户名称 |
| notes | TEXT | NULL | - | 备注信息 |
| status | VARCHAR(20) | NOT NULL | 'completed' | 出库状态 |
| created_by | VARCHAR(100) | NOT NULL | 'system' | 创建人 |
| updated_by | VARCHAR(100) | NOT NULL | 'system' | 更新人 |
| created_at | TIMESTAMP | NOT NULL | NOW() | 创建时间 |
| updated_at | TIMESTAMP | NOT NULL | NOW() | 更新时间 |

**外键约束**:
```sql
ALTER TABLE outbound_records 
ADD CONSTRAINT fk_outbound_product 
FOREIGN KEY (product_id) REFERENCES products(id) 
ON DELETE CASCADE ON UPDATE CASCADE;
```

**索引设计**:
```sql
-- 商品外键索引
CREATE INDEX idx_outbound_product_id ON outbound_records(product_id);

-- 日期索引
CREATE INDEX idx_outbound_date ON outbound_records(date);

-- 状态索引
CREATE INDEX idx_outbound_status ON outbound_records(status);

-- 客户名称索引
CREATE INDEX idx_outbound_customer ON outbound_records(customer_name);
```

**示例数据**:
```json
{
  "id": 42,
  "product_id": 15,
  "quantity": 10,
  "unit_price": 3.50,
  "total_amount": 35.00,
  "date": "2025-01-08",
  "customer_name": "张三",
  "notes": "零售出库",
  "status": "completed",
  "created_by": "system",
  "updated_by": "system",
  "created_at": "2025-02-01T10:00:00Z",
  "updated_at": "2025-02-01T10:00:00Z"
}
```

## 🔗 表关系设计

### 主要关联关系

1. **供应商 → 商品** (1:N)
   - `suppliers.id` → `products.supplier_id`
   - 一个供应商可以供应多个商品
   - 商品可以没有关联供应商（supplier_id为NULL）

2. **商品 → 入库记录** (1:N)
   - `products.id` → `inbound_records.product_id`
   - 一个商品可以有多条入库记录

3. **供应商 → 入库记录** (1:N)
   - `suppliers.id` → `inbound_records.supplier_id`
   - 一个供应商可以有多条入库记录

4. **商品 → 出库记录** (1:N)
   - `products.id` → `outbound_records.product_id`
   - 一个商品可以有多条出库记录

### 关联查询示例

**查询商品及其供应商信息**:
```sql
SELECT 
    p.id,
    p.name AS product_name,
    p.brand,
    p.category,
    p.currentStock,
    s.name AS supplier_name,
    s.contact AS supplier_contact
FROM products p
LEFT JOIN suppliers s ON p.supplier_id = s.id
WHERE p.currentStock > 0
ORDER BY p.name;
```

**查询入库记录详情**:
```sql
SELECT 
    ir.id,
    ir.quantity,
    ir.unit_price,
    ir.total_amount,
    ir.date,
    p.name AS product_name,
    p.specification,
    s.name AS supplier_name
FROM inbound_records ir
JOIN products p ON ir.product_id = p.id
JOIN suppliers s ON ir.supplier_id = s.id
WHERE ir.date >= '2025-01-01'
ORDER BY ir.date DESC;
```

**查询出库记录详情**:
```sql
SELECT 
    or.id,
    or.quantity,
    or.unit_price,
    or.total_amount,
    or.date,
    or.customer_name,
    p.name AS product_name,
    p.specification
FROM outbound_records or
JOIN products p ON or.product_id = p.id
WHERE or.date >= '2025-01-01'
ORDER BY or.date DESC;
```

## 📈 业务逻辑实现

### 库存管理逻辑

**入库操作**:
1. 创建入库记录
2. 更新商品库存: `currentStock += quantity`
3. 更新商品进货价格（可选）
4. 维护供应商-商品关联关系

```sql
-- 入库操作事务
BEGIN;
INSERT INTO inbound_records (product_id, supplier_id, quantity, unit_price, total_amount, date, notes)
VALUES (15, 8, 50, 2.50, 125.00, '2025-01-08', '正常入库');

UPDATE products 
SET currentStock = currentStock + 50,
    updated_at = NOW()
WHERE id = 15;

-- 确保供应商-商品关联关系存在
INSERT INTO supplier_products (supplier_id, product_id, is_primary)
VALUES (8, 15, false)
ON CONFLICT (supplier_id, product_id) DO NOTHING;

COMMIT;
```

**出库操作**:
1. 检查库存是否充足
2. 创建出库记录
3. 更新商品库存: `currentStock -= quantity`

```sql
-- 出库操作事务
BEGIN;
-- 检查库存
SELECT currentStock FROM products WHERE id = 15 FOR UPDATE;

-- 如果库存充足，执行出库
INSERT INTO outbound_records (product_id, quantity, unit_price, total_amount, date, customer_name, notes)
VALUES (15, 10, 3.50, 35.00, '2025-01-08', '张三', '零售出库');

UPDATE products 
SET currentStock = currentStock - 10,
    updated_at = NOW()
WHERE id = 15 AND currentStock >= 10;

-- 验证库存更新成功
IF NOT FOUND THEN
    ROLLBACK;
    RAISE EXCEPTION '库存不足，无法完成出库操作';
END IF;

COMMIT;
```

### 供应商商品关联管理

**添加供应商-商品关联**:
```sql
-- 添加供应商-商品关联
INSERT INTO supplier_products (supplier_id, product_id, is_primary)
VALUES (?, ?, ?)
ON CONFLICT (supplier_id, product_id) 
DO UPDATE SET is_primary = EXCLUDED.is_primary;
```

**设置主要供应商**:
```sql
-- 设置主要供应商（确保每个商品只有一个主要供应商）
BEGIN;

-- 先取消其他供应商的主要状态
UPDATE supplier_products 
SET is_primary = false 
WHERE product_id = ? AND supplier_id != ?;

-- 设置新的主要供应商
UPDATE supplier_products 
SET is_primary = true 
WHERE product_id = ? AND supplier_id = ?;

COMMIT;
```

**删除供应商-商品关联**:
```sql
-- 删除供应商-商品关联
DELETE FROM supplier_products 
WHERE supplier_id = ? AND product_id = ?;
```

### 数据完整性约束

**数据完整性约束**:

1. **外键约束**: 确保数据引用完整性
   - `supplier_products.supplier_id` → `suppliers.id`
   - `supplier_products.product_id` → `products.id`
   - `inbound_records.product_id` → `products.id`
   - `inbound_records.supplier_id` → `suppliers.id`
   - `outbound_records.product_id` → `products.id`

2. **唯一约束**: 防止重复数据
   - `suppliers.name` 供应商名称唯一
   - `products.barcode` 商品条码唯一（非空时）
   - `supplier_products(supplier_id, product_id)` 供应商-商品关联唯一

3. **检查约束**: 确保数据有效性
```sql
-- 价格必须为正数
ALTER TABLE products ADD CONSTRAINT chk_products_price_positive 
CHECK (purchasePrice > 0 AND inputPrice > 0 AND retailPrice > 0);

-- 库存数量不能为负数
ALTER TABLE products ADD CONSTRAINT chk_products_stock_non_negative 
CHECK (currentStock >= 0);

-- 入库数量必须为正数
ALTER TABLE inbound_records ADD CONSTRAINT chk_inbound_quantity_positive 
CHECK (quantity > 0 AND unit_price > 0);

-- 出库数量必须为正数
ALTER TABLE outbound_records ADD CONSTRAINT chk_outbound_quantity_positive 
CHECK (quantity > 0 AND unit_price > 0);
```

4. **触发器**: 自动维护数据一致性
```sql
-- 自动更新商品的updated_at字段
CREATE OR REPLACE FUNCTION update_product_timestamp()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_update_product_timestamp
    BEFORE UPDATE ON products
    FOR EACH ROW
    EXECUTE FUNCTION update_product_timestamp();
```

## 🔍 查询优化

### 常用查询索引设计

#### 1. 库存预警查询
```sql
-- 查询库存不足的商品
SELECT p.*, sp.supplier_id, s.name as supplier_name
FROM products p
LEFT JOIN supplier_products sp ON p.id = sp.product_id AND sp.is_primary = true
LEFT JOIN suppliers s ON sp.supplier_id = s.id
WHERE p.currentStock <= p.stockAlert;

-- 优化索引
CREATE INDEX idx_products_stock_alert ON products(currentStock, stockAlert);
CREATE INDEX idx_supplier_products_primary ON supplier_products(is_primary) WHERE is_primary = true;
```

#### 2. 供应商商品查询
```sql
-- 查询指定供应商的所有商品
SELECT p.*, sp.is_primary
FROM products p
INNER JOIN supplier_products sp ON p.id = sp.product_id
WHERE sp.supplier_id = ?;

-- 优化索引
CREATE INDEX idx_supplier_products_supplier ON supplier_products(supplier_id);
```

#### 3. 商品供应商查询
```sql
-- 查询指定商品的所有供应商
SELECT s.*, sp.is_primary
FROM suppliers s
INNER JOIN supplier_products sp ON s.id = sp.supplier_id
WHERE sp.product_id = ? AND s.status = 'active';

-- 优化索引
CREATE INDEX idx_supplier_products_product ON supplier_products(product_id);
```

#### 4. 销售统计查询
```sql
-- 按月统计销售数据
SELECT 
    DATE_TRUNC('month', created_at) as month,
    SUM(quantity * unit_price) as total_sales,
    SUM(quantity) as total_quantity
FROM outbound_records 
WHERE created_at >= DATE_TRUNC('year', CURRENT_DATE)
GROUP BY DATE_TRUNC('month', created_at)
ORDER BY month;

-- 优化索引
CREATE INDEX idx_outbound_records_date ON outbound_records(created_at);
```

#### 5. 入库历史查询
```sql
-- 查询商品的入库历史（包含供应商信息）
SELECT ir.*, s.name as supplier_name, p.name as product_name
FROM inbound_records ir
INNER JOIN suppliers s ON ir.supplier_id = s.id
INNER JOIN products p ON ir.product_id = p.id
WHERE ir.product_id = ?
ORDER BY ir.created_at DESC;

-- 优化索引
CREATE INDEX idx_inbound_records_product_date ON inbound_records(product_id, created_at);
```

### 性能优化建议

1. **分页查询优化**
   ```sql
   -- 使用LIMIT和OFFSET进行分页
   SELECT * FROM products 
   ORDER BY id 
   LIMIT 20 OFFSET 0;
   ```

2. **复合索引使用**
   - 将最常用的查询条件放在索引前面
   - 考虑查询的选择性和频率

3. **避免全表扫描**
   - 在WHERE子句中使用索引字段
   - 避免在索引字段上使用函数

## 🛡️ 数据安全

### 备份策略
- **自动备份**: Supabase提供自动备份功能
- **定期导出**: 定期导出重要数据
- **版本控制**: 数据库结构变更版本控制

### 权限控制
- **行级安全**: 使用Supabase RLS功能
- **API权限**: 通过API层控制数据访问
- **审计日志**: 记录重要操作日志

## ✅ 数据库结构验证

### 表结构验证查询

```sql
-- 验证所有表是否创建成功
SELECT table_name, table_type 
FROM information_schema.tables 
WHERE table_schema = 'public' 
AND table_name IN ('suppliers', 'products', 'supplier_products', 'inbound_records', 'outbound_records');

-- 验证外键约束
SELECT 
    tc.table_name, 
    tc.constraint_name, 
    tc.constraint_type,
    kcu.column_name,
    ccu.table_name AS foreign_table_name,
    ccu.column_name AS foreign_column_name
FROM information_schema.table_constraints AS tc 
JOIN information_schema.key_column_usage AS kcu
    ON tc.constraint_name = kcu.constraint_name
    AND tc.table_schema = kcu.table_schema
JOIN information_schema.constraint_column_usage AS ccu
    ON ccu.constraint_name = tc.constraint_name
    AND ccu.table_schema = tc.table_schema
WHERE tc.constraint_type = 'FOREIGN KEY' 
AND tc.table_schema = 'public';

-- 验证索引创建
SELECT 
    schemaname,
    tablename,
    indexname,
    indexdef
FROM pg_indexes 
WHERE schemaname = 'public'
AND tablename IN ('suppliers', 'products', 'supplier_products', 'inbound_records', 'outbound_records')
ORDER BY tablename, indexname;
```

### 数据一致性检查

```sql
-- 检查孤立的商品记录（没有供应商关联）
SELECT p.id, p.name 
FROM products p
LEFT JOIN supplier_products sp ON p.id = sp.product_id
WHERE sp.product_id IS NULL;

-- 检查入库记录的数据完整性
SELECT COUNT(*) as invalid_inbound_records
FROM inbound_records ir
LEFT JOIN products p ON ir.product_id = p.id
LEFT JOIN suppliers s ON ir.supplier_id = s.id
WHERE p.id IS NULL OR s.id IS NULL;

-- 检查出库记录的数据完整性
SELECT COUNT(*) as invalid_outbound_records
FROM outbound_records or_
LEFT JOIN products p ON or_.product_id = p.id
WHERE p.id IS NULL;

-- 检查供应商-商品关联的完整性
SELECT COUNT(*) as invalid_supplier_product_relations
FROM supplier_products sp
LEFT JOIN suppliers s ON sp.supplier_id = s.id
LEFT JOIN products p ON sp.product_id = p.id
WHERE s.id IS NULL OR p.id IS NULL;
```

### 性能测试查询

```sql
-- 测试库存预警查询性能
EXPLAIN ANALYZE
SELECT p.*, sp.supplier_id, s.name as supplier_name
FROM products p
LEFT JOIN supplier_products sp ON p.id = sp.product_id AND sp.is_primary = true
LEFT JOIN suppliers s ON sp.supplier_id = s.id
WHERE p.currentStock <= p.stockAlert;

-- 测试供应商商品查询性能
EXPLAIN ANALYZE
SELECT p.*, sp.is_primary
FROM products p
INNER JOIN supplier_products sp ON p.id = sp.product_id
WHERE sp.supplier_id = 1;
```

---

## 📝 更新日志

### v2.1.0 (2025-02-01)
- **字段增强**: 为 `inbound_records` 和 `outbound_records` 表添加审计字段
- **新增字段**: `created_by` - 记录创建人，默认值 'system'
- **新增字段**: `updated_by` - 记录更新人，默认值 'system'
- **触发器**: 添加自动更新 `updated_at` 时间戳的触发器
- **数据完整性**: 解决前端入库操作中的字段缺失问题

### v2.0.0 (2025-01-31)
- **重大变更**: 将供应商-商品关系从一对多改为多对多
- **新增**: `supplier_products` 中间表管理供应商-商品关联
- **移除**: `products` 表中的 `supplier_id` 外键字段
- **优化**: 更新所有相关查询和索引设计
- **增强**: 支持一个商品对应多个供应商的业务场景

### v1.0.0 (2025-01-08)
- 初始数据库设计
- 基础表结构定义
- 核心业务逻辑实现

---

**✅ 数据库结构验证通过** - 所有表、约束、索引和触发器已正确创建并验证完成。

---

**设计原则**: 本数据库设计遵循关系型数据库规范化原则，通过外键关联保证数据完整性，采用合理的索引策略提升查询性能，为便利店进销存系统提供稳定可靠的数据支撑。