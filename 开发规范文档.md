# 开发规范文档

> 便利店进销存系统开发规范和最佳实践  
> 确保代码质量和团队协作效率  
> 更新时间: 2025年1月8日  
> 版本: v1.0.0

## 🎯 开发原则

### 核心原则
1. **代码可读性优先** - 清晰的命名和结构
2. **一致性** - 统一的代码风格和约定
3. **可维护性** - 模块化设计和文档完善
4. **安全性** - 数据验证和权限控制
5. **性能优化** - 高效的算法和资源使用

### 技术栈规范
- **前端**: Vue 3 + Composition API + TypeScript
- **后端**: Node.js + Express.js + ES6+
- **数据库**: Supabase PostgreSQL
- **工具**: ESLint + Prettier + Husky

## 📁 项目结构规范

### 目录结构
```
ke/
├── frontend/                 # 前端应用
│   ├── src/
│   │   ├── components/      # 可复用组件
│   │   ├── views/          # 页面组件
│   │   ├── router/         # 路由配置
│   │   ├── stores/         # 状态管理
│   │   ├── utils/          # 工具函数
│   │   ├── api/            # API接口
│   │   └── assets/         # 静态资源
│   ├── public/             # 公共资源
│   └── tests/              # 测试文件
├── backend/                 # 后端应用
│   ├── routes/             # 路由模块
│   ├── models/             # 数据模型
│   ├── middleware/         # 中间件
│   ├── utils/              # 工具函数
│   ├── config/             # 配置文件
│   └── tests/              # 测试文件
├── edge-functions/          # 边缘函数
├── docs/                   # 项目文档
└── scripts/                # 构建脚本
```

### 文件命名规范

**1. 组件文件**
```javascript
// ✅ 正确 - PascalCase
ProductList.vue
SupplierForm.vue
InventoryChart.vue

// ❌ 错误
productList.vue
supplier-form.vue
inventory_chart.vue
```

**2. 工具文件**
```javascript
// ✅ 正确 - camelCase
dateUtils.js
apiClient.js
validationHelpers.js

// ❌ 错误
DateUtils.js
api-client.js
validation_helpers.js
```

**3. 路由文件**
```javascript
// ✅ 正确 - kebab-case
product-management.js
supplier-list.js
inventory-report.js

// ❌ 错误
ProductManagement.js
supplierList.js
inventory_report.js
```

## 💻 前端开发规范

### Vue组件规范

**1. 组件结构**
```vue
<template>
  <!-- 模板内容 -->
</template>

<script setup>
// 导入依赖
import { ref, computed, onMounted } from 'vue'
import { useRouter } from 'vue-router'

// Props定义
const props = defineProps({
  productId: {
    type: String,
    required: true
  },
  showActions: {
    type: Boolean,
    default: true
  }
})

// Emits定义
const emit = defineEmits(['update', 'delete'])

// 响应式数据
const loading = ref(false)
const products = ref([])

// 计算属性
const filteredProducts = computed(() => {
  return products.value.filter(p => p.status === 'active')
})

// 方法
const fetchProducts = async () => {
  try {
    loading.value = true
    // API调用
  } catch (error) {
    console.error('获取商品失败:', error)
  } finally {
    loading.value = false
  }
}

// 生命周期
onMounted(() => {
  fetchProducts()
})
</script>

<style scoped>
/* 组件样式 */
</style>
```

**2. 命名规范**
```javascript
// ✅ 正确的变量命名
const productList = ref([])
const isLoading = ref(false)
const currentUser = ref(null)

// ✅ 正确的方法命名
const fetchProductList = async () => {}
const handleSubmit = () => {}
const validateForm = () => {}

// ✅ 正确的计算属性命名
const filteredProducts = computed(() => {})
const totalAmount = computed(() => {})
const isFormValid = computed(() => {})
```

**3. 组件通信**
```javascript
// ✅ 使用Props传递数据
const props = defineProps({
  product: {
    type: Object,
    required: true,
    validator: (value) => {
      return value && typeof value.id === 'string'
    }
  }
})

// ✅ 使用Emits传递事件
const emit = defineEmits(['update:product', 'delete'])

const handleUpdate = (newProduct) => {
  emit('update:product', newProduct)
}

// ✅ 使用Provide/Inject共享数据
import { provide, inject } from 'vue'

// 父组件
provide('userInfo', userInfo)

// 子组件
const userInfo = inject('userInfo')
```

### 状态管理规范

**1. Pinia Store结构**
```javascript
// stores/productStore.js
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'
import { productApi } from '@/api/product'

export const useProductStore = defineStore('product', () => {
  // State
  const products = ref([])
  const loading = ref(false)
  const error = ref(null)

  // Getters
  const activeProducts = computed(() => 
    products.value.filter(p => p.status === 'active')
  )

  const productCount = computed(() => products.value.length)

  // Actions
  const fetchProducts = async () => {
    try {
      loading.value = true
      error.value = null
      const response = await productApi.getAll()
      products.value = response.data
    } catch (err) {
      error.value = err.message
      throw err
    } finally {
      loading.value = false
    }
  }

  const addProduct = async (product) => {
    try {
      const response = await productApi.create(product)
      products.value.push(response.data)
      return response.data
    } catch (err) {
      error.value = err.message
      throw err
    }
  }

  return {
    // State
    products,
    loading,
    error,
    // Getters
    activeProducts,
    productCount,
    // Actions
    fetchProducts,
    addProduct
  }
})
```

### API调用规范

**1. API客户端配置**
```javascript
// api/client.js
import axios from 'axios'

const apiClient = axios.create({
  baseURL: import.meta.env.VITE_API_BASE_URL,
  timeout: 10000,
  headers: {
    'Content-Type': 'application/json'
  }
})

// 请求拦截器
apiClient.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem('token')
    if (token) {
      config.headers.Authorization = `Bearer ${token}`
    }
    return config
  },
  (error) => Promise.reject(error)
)

// 响应拦截器
apiClient.interceptors.response.use(
  (response) => response,
  (error) => {
    if (error.response?.status === 401) {
      // 处理未授权
      localStorage.removeItem('token')
      window.location.href = '/login'
    }
    return Promise.reject(error)
  }
)

export default apiClient
```

**2. API模块化**
```javascript
// api/product.js
import apiClient from './client'

export const productApi = {
  // 获取商品列表
  getAll: (params = {}) => {
    return apiClient.get('/api/products', { params })
  },

  // 获取单个商品
  getById: (id) => {
    return apiClient.get(`/api/products/${id}`)
  },

  // 创建商品
  create: (data) => {
    return apiClient.post('/api/products', data)
  },

  // 更新商品
  update: (id, data) => {
    return apiClient.put(`/api/products/${id}`, data)
  },

  // 删除商品
  delete: (id) => {
    return apiClient.delete(`/api/products/${id}`)
  },

  // 搜索商品
  search: (query) => {
    return apiClient.get('/api/products/search', {
      params: { q: query }
    })
  }
}
```

## 🔧 后端开发规范

### Express应用结构

**1. 路由模块化**
```javascript
// routes/products.js
const express = require('express')
const router = express.Router()
const { body, param, query, validationResult } = require('express-validator')
const productController = require('../controllers/productController')
const authMiddleware = require('../middleware/auth')

// 获取商品列表
router.get('/', 
  [
    query('page').optional().isInt({ min: 1 }),
    query('limit').optional().isInt({ min: 1, max: 100 }),
    query('category').optional().isString().trim()
  ],
  productController.getProducts
)

// 获取单个商品
router.get('/:id',
  [
    param('id').isUUID().withMessage('商品ID格式无效')
  ],
  productController.getProductById
)

// 创建商品
router.post('/',
  authMiddleware,
  [
    body('name').notEmpty().withMessage('商品名称不能为空'),
    body('category').notEmpty().withMessage('商品分类不能为空'),
    body('price').isFloat({ min: 0 }).withMessage('价格必须大于等于0'),
    body('supplier_id').isUUID().withMessage('供应商ID格式无效')
  ],
  productController.createProduct
)

module.exports = router
```

**2. 控制器规范**
```javascript
// controllers/productController.js
const { validationResult } = require('express-validator')
const productService = require('../services/productService')
const logger = require('../utils/logger')

class ProductController {
  // 获取商品列表
  async getProducts(req, res) {
    try {
      // 验证请求参数
      const errors = validationResult(req)
      if (!errors.isEmpty()) {
        return res.status(400).json({
          success: false,
          message: '请求参数无效',
          errors: errors.array()
        })
      }

      const { page = 1, limit = 10, category } = req.query
      
      const result = await productService.getProducts({
        page: parseInt(page),
        limit: parseInt(limit),
        category
      })

      res.json({
        success: true,
        data: result.products,
        pagination: {
          page: result.page,
          limit: result.limit,
          total: result.total,
          totalPages: result.totalPages
        }
      })
    } catch (error) {
      logger.error('获取商品列表失败:', error)
      res.status(500).json({
        success: false,
        message: '服务器内部错误'
      })
    }
  }

  // 创建商品
  async createProduct(req, res) {
    try {
      const errors = validationResult(req)
      if (!errors.isEmpty()) {
        return res.status(400).json({
          success: false,
          message: '请求参数无效',
          errors: errors.array()
        })
      }

      const productData = req.body
      const newProduct = await productService.createProduct(productData)

      logger.info('商品创建成功:', { productId: newProduct.id })
      
      res.status(201).json({
        success: true,
        data: newProduct,
        message: '商品创建成功'
      })
    } catch (error) {
      logger.error('创建商品失败:', error)
      
      if (error.code === '23505') { // 唯一约束违反
        return res.status(409).json({
          success: false,
          message: '商品已存在'
        })
      }

      res.status(500).json({
        success: false,
        message: '服务器内部错误'
      })
    }
  }
}

module.exports = new ProductController()
```

**3. 服务层规范**
```javascript
// services/productService.js
const supabase = require('../config/supabase')
const logger = require('../utils/logger')

class ProductService {
  async getProducts({ page = 1, limit = 10, category }) {
    try {
      let query = supabase
        .from('products')
        .select(`
          *,
          suppliers (
            id,
            name,
            contact_person
          )
        `)

      // 添加分类过滤
      if (category) {
        query = query.eq('category', category)
      }

      // 添加分页
      const from = (page - 1) * limit
      const to = from + limit - 1
      
      query = query.range(from, to)

      const { data, error, count } = await query

      if (error) {
        throw error
      }

      return {
        products: data,
        page,
        limit,
        total: count,
        totalPages: Math.ceil(count / limit)
      }
    } catch (error) {
      logger.error('获取商品列表失败:', error)
      throw error
    }
  }

  async createProduct(productData) {
    try {
      const { data, error } = await supabase
        .from('products')
        .insert([{
          ...productData,
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString()
        }])
        .select()
        .single()

      if (error) {
        throw error
      }

      return data
    } catch (error) {
      logger.error('创建商品失败:', error)
      throw error
    }
  }
}

module.exports = new ProductService()
```

### 中间件规范

**1. 认证中间件**
```javascript
// middleware/auth.js
const jwt = require('jsonwebtoken')
const logger = require('../utils/logger')

const authMiddleware = (req, res, next) => {
  try {
    const token = req.header('Authorization')?.replace('Bearer ', '')
    
    if (!token) {
      return res.status(401).json({
        success: false,
        message: '访问令牌缺失'
      })
    }

    const decoded = jwt.verify(token, process.env.JWT_SECRET)
    req.user = decoded
    next()
  } catch (error) {
    logger.warn('认证失败:', { error: error.message })
    res.status(401).json({
      success: false,
      message: '访问令牌无效'
    })
  }
}

module.exports = authMiddleware
```

**2. 错误处理中间件**
```javascript
// middleware/errorHandler.js
const logger = require('../utils/logger')

const errorHandler = (err, req, res, next) => {
  logger.error('未处理的错误:', {
    error: err.message,
    stack: err.stack,
    url: req.url,
    method: req.method,
    ip: req.ip
  })

  // 数据库错误
  if (err.code === '23505') {
    return res.status(409).json({
      success: false,
      message: '数据已存在'
    })
  }

  if (err.code === '23503') {
    return res.status(400).json({
      success: false,
      message: '关联数据不存在'
    })
  }

  // 验证错误
  if (err.name === 'ValidationError') {
    return res.status(400).json({
      success: false,
      message: '数据验证失败',
      errors: err.errors
    })
  }

  // 默认错误
  res.status(500).json({
    success: false,
    message: '服务器内部错误'
  })
}

module.exports = errorHandler
```

## 🗃️ 数据库操作规范

### 查询规范

**1. 基础查询**
```javascript
// ✅ 正确 - 使用参数化查询
const getProductById = async (id) => {
  const { data, error } = await supabase
    .from('products')
    .select('*')
    .eq('id', id)
    .single()
  
  if (error) throw error
  return data
}

// ❌ 错误 - 字符串拼接（SQL注入风险）
const getProductById = async (id) => {
  const query = `SELECT * FROM products WHERE id = '${id}'`
  // 不安全的查询方式
}
```

**2. 复杂查询**
```javascript
// ✅ 关联查询
const getProductsWithSuppliers = async () => {
  const { data, error } = await supabase
    .from('products')
    .select(`
      id,
      name,
      category,
      price,
      currentStock,
      suppliers (
        id,
        name,
        contact_person,
        phone
      )
    `)
    .eq('status', 'active')
    .order('created_at', { ascending: false })

  if (error) throw error
  return data
}

// ✅ 聚合查询
const getInventoryStats = async () => {
  const { data, error } = await supabase
    .rpc('get_inventory_stats')

  if (error) throw error
  return data
}
```

**3. 事务处理**
```javascript
// ✅ 使用RPC处理复杂事务
const processOutbound = async (outboundData) => {
  const { data, error } = await supabase
    .rpc('process_outbound_transaction', {
      product_id: outboundData.product_id,
      quantity: outboundData.quantity,
      unit_price: outboundData.unit_price,
      customer_info: outboundData.customer_info
    })

  if (error) throw error
  return data
}
```

### 数据验证规范

**1. 输入验证**
```javascript
// utils/validation.js
const Joi = require('joi')

const productSchema = Joi.object({
  name: Joi.string().min(1).max(100).required(),
  category: Joi.string().min(1).max(50).required(),
  price: Joi.number().min(0).precision(2).required(),
  supplier_id: Joi.string().uuid().required(),
  description: Joi.string().max(500).optional(),
  unit: Joi.string().max(20).optional()
})

const validateProduct = (data) => {
  const { error, value } = productSchema.validate(data)
  if (error) {
    throw new Error(`数据验证失败: ${error.details[0].message}`)
  }
  return value
}

module.exports = { validateProduct }
```

**2. 业务逻辑验证**
```javascript
// services/validationService.js
class ValidationService {
  static async validateProductStock(productId, requiredQuantity) {
    const { data: product } = await supabase
      .from('products')
      .select('currentStock')
      .eq('id', productId)
      .single()

    if (!product) {
      throw new Error('商品不存在')
    }

    if (product.currentStock < requiredQuantity) {
      throw new Error('库存不足')
    }

    return true
  }

  static async validateSupplierExists(supplierId) {
    const { data: supplier } = await supabase
      .from('suppliers')
      .select('id')
      .eq('id', supplierId)
      .single()

    if (!supplier) {
      throw new Error('供应商不存在')
    }

    return true
  }
}

module.exports = ValidationService
```

## 🧪 测试规范

### 单元测试

**1. 前端组件测试**
```javascript
// tests/components/ProductList.test.js
import { mount } from '@vue/test-utils'
import { describe, it, expect, vi } from 'vitest'
import ProductList from '@/components/ProductList.vue'

describe('ProductList', () => {
  it('应该正确渲染商品列表', () => {
    const products = [
      { id: '1', name: '商品1', price: 10.00 },
      { id: '2', name: '商品2', price: 20.00 }
    ]

    const wrapper = mount(ProductList, {
      props: { products }
    })

    expect(wrapper.findAll('.product-item')).toHaveLength(2)
    expect(wrapper.text()).toContain('商品1')
    expect(wrapper.text()).toContain('商品2')
  })

  it('应该正确处理删除事件', async () => {
    const products = [{ id: '1', name: '商品1', price: 10.00 }]
    const wrapper = mount(ProductList, {
      props: { products }
    })

    await wrapper.find('.delete-btn').trigger('click')
    
    expect(wrapper.emitted('delete')).toBeTruthy()
    expect(wrapper.emitted('delete')[0]).toEqual(['1'])
  })
})
```

**2. 后端API测试**
```javascript
// tests/routes/products.test.js
const request = require('supertest')
const app = require('../../app')

describe('Products API', () => {
  describe('GET /api/products', () => {
    it('应该返回商品列表', async () => {
      const response = await request(app)
        .get('/api/products')
        .expect(200)

      expect(response.body.success).toBe(true)
      expect(Array.isArray(response.body.data)).toBe(true)
    })

    it('应该支持分页参数', async () => {
      const response = await request(app)
        .get('/api/products?page=1&limit=5')
        .expect(200)

      expect(response.body.pagination).toBeDefined()
      expect(response.body.pagination.page).toBe(1)
      expect(response.body.pagination.limit).toBe(5)
    })
  })

  describe('POST /api/products', () => {
    it('应该创建新商品', async () => {
      const productData = {
        name: '测试商品',
        category: '测试分类',
        price: 99.99,
        supplier_id: 'valid-uuid'
      }

      const response = await request(app)
        .post('/api/products')
        .send(productData)
        .expect(201)

      expect(response.body.success).toBe(true)
      expect(response.body.data.name).toBe('测试商品')
    })

    it('应该验证必填字段', async () => {
      const response = await request(app)
        .post('/api/products')
        .send({})
        .expect(400)

      expect(response.body.success).toBe(false)
      expect(response.body.errors).toBeDefined()
    })
  })
})
```

### 集成测试

**1. 端到端测试**
```javascript
// tests/e2e/product-management.test.js
import { test, expect } from '@playwright/test'

test.describe('商品管理', () => {
  test('应该能够创建新商品', async ({ page }) => {
    await page.goto('/products')
    
    // 点击新增按钮
    await page.click('[data-testid="add-product-btn"]')
    
    // 填写表单
    await page.fill('[data-testid="product-name"]', '测试商品')
    await page.fill('[data-testid="product-category"]', '测试分类')
    await page.fill('[data-testid="product-price"]', '99.99')
    await page.selectOption('[data-testid="supplier-select"]', 'supplier-1')
    
    // 提交表单
    await page.click('[data-testid="submit-btn"]')
    
    // 验证结果
    await expect(page.locator('.success-message')).toBeVisible()
    await expect(page.locator('.product-list')).toContainText('测试商品')
  })

  test('应该能够搜索商品', async ({ page }) => {
    await page.goto('/products')
    
    // 输入搜索关键词
    await page.fill('[data-testid="search-input"]', '测试')
    await page.press('[data-testid="search-input"]', 'Enter')
    
    // 验证搜索结果
    await expect(page.locator('.product-item')).toContainText('测试')
  })
})
```

## 📝 代码质量规范

### ESLint配置

```javascript
// .eslintrc.js
module.exports = {
  root: true,
  env: {
    node: true,
    browser: true,
    es2021: true
  },
  extends: [
    'eslint:recommended',
    '@vue/eslint-config-prettier',
    '@vue/eslint-config-typescript'
  ],
  parserOptions: {
    ecmaVersion: 2021,
    sourceType: 'module'
  },
  rules: {
    // 代码质量
    'no-console': process.env.NODE_ENV === 'production' ? 'warn' : 'off',
    'no-debugger': process.env.NODE_ENV === 'production' ? 'warn' : 'off',
    'no-unused-vars': 'warn',
    'no-undef': 'error',
    
    // 代码风格
    'indent': ['error', 2],
    'quotes': ['error', 'single'],
    'semi': ['error', 'never'],
    'comma-dangle': ['error', 'never'],
    
    // Vue特定规则
    'vue/multi-word-component-names': 'off',
    'vue/no-unused-components': 'warn',
    'vue/no-unused-vars': 'warn'
  }
}
```

### Prettier配置

```javascript
// .prettierrc.js
module.exports = {
  semi: false,
  singleQuote: true,
  tabWidth: 2,
  trailingComma: 'none',
  printWidth: 80,
  bracketSpacing: true,
  arrowParens: 'avoid',
  endOfLine: 'lf'
}
```

### Git Hooks配置

```javascript
// .husky/pre-commit
#!/usr/bin/env sh
. "$(dirname -- "$0")/_/husky.sh"

# 运行代码检查
npm run lint

# 运行类型检查
npm run type-check

# 运行测试
npm run test:unit
```

## 📚 文档规范

### 代码注释

**1. 函数注释**
```javascript
/**
 * 获取商品列表
 * @param {Object} options - 查询选项
 * @param {number} options.page - 页码
 * @param {number} options.limit - 每页数量
 * @param {string} options.category - 商品分类
 * @returns {Promise<Object>} 商品列表和分页信息
 * @throws {Error} 当查询失败时抛出错误
 */
const getProducts = async (options = {}) => {
  // 实现代码
}
```

**2. 组件注释**
```vue
<template>
  <!-- 商品列表容器 -->
  <div class="product-list">
    <!-- 搜索表单 -->
    <div class="search-form">
      <!-- 搜索输入框 -->
      <input v-model="searchQuery" placeholder="搜索商品..." />
    </div>
    
    <!-- 商品列表 -->
    <div class="products">
      <div 
        v-for="product in filteredProducts" 
        :key="product.id"
        class="product-item"
      >
        {{ product.name }}
      </div>
    </div>
  </div>
</template>
```

### README文档

```markdown
# 便利店进销存系统

## 项目简介
基于Vue 3和Node.js的现代化进销存管理系统

## 技术栈
- 前端: Vue 3 + Vite + Element Plus
- 后端: Node.js + Express + Supabase
- 数据库: PostgreSQL

## 快速开始

### 环境要求
- Node.js >= 16.0.0
- npm >= 8.0.0

### 安装依赖
```bash
# 前端
cd frontend && npm install

# 后端
cd backend && npm install
```

### 启动开发服务
```bash
# 前端开发服务
npm run dev

# 后端服务
npm run start:dev
```

## 项目结构
```
ke/
├── frontend/     # 前端应用
├── backend/      # 后端应用
└── docs/         # 项目文档
```

## 开发规范
请参考 [开发规范文档](./docs/开发规范文档.md)

## API文档
请参考 [API接口文档](./docs/API接口文档.md)
```

## 🔄 版本控制规范

### Git提交规范

**1. 提交信息格式**
```
<type>(<scope>): <subject>

<body>

<footer>
```

**2. 类型说明**
- `feat`: 新功能
- `fix`: 修复bug
- `docs`: 文档更新
- `style`: 代码格式调整
- `refactor`: 代码重构
- `test`: 测试相关
- `chore`: 构建工具或辅助工具的变动

**3. 提交示例**
```bash
# 新功能
git commit -m "feat(product): 添加商品搜索功能"

# 修复bug
git commit -m "fix(api): 修复商品列表分页问题"

# 文档更新
git commit -m "docs: 更新API接口文档"

# 代码重构
git commit -m "refactor(utils): 优化日期处理工具函数"
```

### 分支管理

**1. 分支命名规范**
```bash
# 功能分支
feature/product-search
feature/supplier-management

# 修复分支
fix/inventory-calculation
fix/api-validation

# 发布分支
release/v1.2.0

# 热修复分支
hotfix/critical-bug-fix
```

**2. 工作流程**
```bash
# 创建功能分支
git checkout -b feature/new-feature

# 开发完成后合并到develop
git checkout develop
git merge feature/new-feature

# 发布时合并到main
git checkout main
git merge develop
git tag v1.0.0
```

## 🚀 部署规范

### 环境配置

**1. 开发环境**
- 本地开发服务器
- 模拟数据和API
- 热重载和调试工具

**2. 测试环境**
- 真实数据库连接
- 完整功能测试
- 性能监控

**3. 生产环境**
- 优化构建版本
- 安全配置
- 监控和日志

### 部署检查清单

- [ ] 代码通过所有测试
- [ ] 代码通过质量检查
- [ ] 环境变量配置正确
- [ ] 数据库迁移完成
- [ ] 静态资源优化
- [ ] 安全配置检查
- [ ] 监控和日志配置
- [ ] 备份策略确认

---

**维护说明**: 本规范文档应定期更新，确保与项目发展保持同步。所有团队成员都应遵循这些规范，以确保代码质量和项目的可维护性。